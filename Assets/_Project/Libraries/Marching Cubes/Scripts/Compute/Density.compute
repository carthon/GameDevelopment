#pragma kernel CSMain
#include "Includes/Noise.compute"
#define PI 3.14159265359

RWTexture3D<float> DensityTexture;
//RWTexture2D<float> ContinentalnessTexture;
//RWTexture2D<float> ErosionTexture;
//RWTexture2D<float> PeekAndValleysTexture;
//RWTexture2D<float> TemperatureTexture;
//RWTexture2D<float> HumidityTexture;
//RWTexture3D<float> SquashFactorTexture;
int textureSize;

float planetSize;
float noiseScale;
float noiseHeightMultiplier;

float fbm(int numLayers, float lacunarity, float persistence, float scale, float3 pos) {
	float noise = 0;
	float frequency = scale / 100;
	float amplitude = 1;

	for (int i = 0; i < numLayers; i ++) {
		float n = 1-abs(snoise(pos * frequency)*2-1);
		//n*=n;
		noise += n * amplitude;

		amplitude *= persistence;
		frequency *= lacunarity;
	}

	return noise;
}
float fbm2d(int numLayers, float lacunarity, float persistence, float scale, float2 pos) {	
	float noise = 0;
	float frequency = scale / 100;
	float amplitude = 1;

	for (int i = 0; i < numLayers; i ++) {
		float n = 1-abs(SNoise2D(pos * frequency)*2-1);
		//n*=n;
		noise += n * amplitude;

		amplitude *= persistence;
		frequency *= lacunarity;
	}
	return noise;
}

float2 SphericalToEquirectangular(float3 position)
{
	// Normalizar la posición para obtener coordenadas unitarias en la esfera
	float3 normalizedPos = normalize(position);

	// Calcular la longitud (lambda) y la latitud (phi)
	float lambda = atan2(normalizedPos.z, normalizedPos.x); // Longitud
	float phi = asin(normalizedPos.y); // Latitud

	// Convertir los ángulos a coordenadas 2D (u, v)
	float u = (lambda + PI) / (2 * PI); // Normalizar longitud a [0, 1]
	float v = (phi + (PI / 2)) / PI; // Normalizar latitud a [0, 1]

	return float2(u, v);
}

float CalculateHeight(float3 position, float radius)
{
	// Calcular la altura como la distancia desde el centro
	return length(position) / radius;
}

float calculateSphericalDensity(int3 cell) {
	float3 worldPos = (cell / float(textureSize-1.0) - 0.5f) * planetSize;
	float2 equirectangularPos = SphericalToEquirectangular(worldPos);

	float halfS = planetSize / 2;
	float maxD = length(float3(halfS,halfS,halfS));

	float fudge = 1;

	float density = length(worldPos) / (maxD + fudge) - 0.5;

	// Noise
	float noiseDensity = fbm(6, 2, 0.5, noiseScale, worldPos) * noiseHeightMultiplier;
	float noiseContinentalness = fbm2d(6, 2, 0.5, noiseScale, equirectangularPos) * noiseHeightMultiplier;
	float noiseErosion = fbm2d(6, 2, 0.5, noiseScale, equirectangularPos) * noiseHeightMultiplier;
	float noisePeaksAndValleys = fbm2d(6, 2, 0.5, noiseScale, equirectangularPos) * noiseHeightMultiplier;

	density += noiseDensity;
	//ContinentalnessTexture[cell] = noiseContinentalness;


	return density;
}

float calculateDensity(int3 cell){
	float3 worldPos = (cell / float(textureSize-1.0) - 0.5f) * planetSize;
	float density = 0;
	// Noise
	float noise = fbm(6, 2, 0.5, noiseScale, worldPos) * noiseHeightMultiplier;
	//if (noise < 0)
	density += noise;
	return density;
}

[numthreads(8,8,8)]
void CSMain (int3 id : SV_DispatchThreadID)
{
	if (id.x >= textureSize || id.y >= textureSize || id.z >= textureSize) {
		return;
	}

	float density = 0;

	const int b = 1;
	if (id.x >= textureSize-b || id.y >= textureSize-b || id.z >= textureSize-b) {
		density = 1;
	}
	else if (id.x <= b || id.y <= b || id.z <=b) {
		density = 1;
	}
	else {
		density = calculateSphericalDensity(id);
	}
	DensityTexture[id] = density;
}
