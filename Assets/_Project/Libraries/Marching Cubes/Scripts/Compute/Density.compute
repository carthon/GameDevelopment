#pragma kernel CSMain
#include "Includes/Noise.compute"
#include "Includes/Utils.compute"

RWTexture3D<float> Generic3DNoiseTexture;

RWTexture2D<float> ContinentalnessTexture;
RWTexture2D<float> ErosionTexture;
RWTexture2D<float> PeekAndValleysTexture;
RWTexture2D<float> TemperatureTexture;
RWTexture2D<float> HumidityTexture;
RWTexture3D<float> SquashFactorTexture;

RWTexture2D<float> Generic2DNoiseTexture;
StructuredBuffer<NoiseParams> NoiseParamsBuffer;

int densityTextureSize;
int sphereTextureHeight;
int sphereTextureWidth;

float planetSize;
float noiseScale;
float noiseHeightMultiplier;
float testValue;

float fbm(int numLayers, float lacunarity, float persistence, float scale, float3 pos) {
	float noise = 0;
	float frequency = scale / 100;
	float amplitude = 1;

	for (int i = 0; i < numLayers; i ++) {
		float n = 1-abs(snoise(pos * frequency)*2-1);
		//n*=n;
		noise += n * amplitude;

		amplitude *= persistence;
		frequency *= lacunarity;
	}

	return noise;
}

float fbm2d(int numLayers, float lacunarity, float persistence, float scale, float2 pos) {	
	float noise = 0;
	float frequency = scale / 100;
	float amplitude = 1;

	for (int i = 0; i < numLayers; i ++) {
		float n = 1-abs(SNoise2D(pos * frequency)*2-1);
		//n*=n;
		noise += n * amplitude;

		amplitude *= persistence;
		frequency *= lacunarity;
	}
	return noise;
}

float periodicNoise2D(float2 pos)
{
	int heightLimit = sphereTextureHeight - 1;
	int widthLimit = sphereTextureWidth - 1;
	
    float2 p = float2(pos.x % widthLimit, pos.y % heightLimit); // Asegura que las coordenadas se repitan dentro del periodo
    float2 q = float2((pos.x - p.x) / widthLimit, (pos.y - p.y) / heightLimit); // Coordenadas locales normalizadas
	
    float a = SNoise2D(p);
	float lookupRange = 1;
    p = float2(pos.x + 1.0 * lookupRange % widthLimit, pos.y % heightLimit);
    float b = SNoise2D(p);
    p = float2(pos.x * lookupRange % widthLimit, pos.y + 1.0 * lookupRange % heightLimit);
    float c = SNoise2D(p);
    p = float2(pos.x + 1.0 * lookupRange % widthLimit, pos.y + 1.0 * lookupRange % heightLimit);
    float d = SNoise2D(p);

    float u = smoothstep(0.0, 1.0, q.x);
    float v = smoothstep(0.0, 1.0, q.y);

    return lerp(lerp(a, b, u), lerp(c, d, u), v);
}

float fbm2dPeriodic(int numLayers, float lacunarity, float persistence, float scale, float2 pos) {  
	float noise = 0;
	float frequency = scale / 100;
	float amplitude = 1;

	for (int i = 0; i < numLayers; i ++) {
		float n = 1 - abs(periodicNoise2D(pos * frequency) * 2 - 1);
		noise += n * amplitude;

		amplitude *= persistence;
		frequency *= lacunarity;
	}
	return noise;
}
float smoothEdge(float value, float edgeDistance, float edgeWidth)
{
	// edgeDistance: distancia del píxel al borde
	// edgeWidth: ancho del borde donde se aplicará el suavizado
	//return smoothstep(edgeWidth, 0.0, edgeDistance) * value;
	return smoothstep(0.0, edgeWidth, edgeDistance);
}
float fbm2dWithEdgeSmoothing(int numLayers, float lacunarity, float persistence, float scale, float2 pos)
{
	float noise = 0;
	float frequency = scale / 100;
	float amplitude = 1;

	for (int i = 0; i < numLayers; i++) {
		float n = periodicNoise2D(pos * frequency);
		noise += n * amplitude;

		amplitude *= persistence;
		frequency *= lacunarity;
	}

	// Calcular la distancia a los bordes
	float2 edgeDistance = min(pos, float2(sphereTextureWidth, sphereTextureHeight) - pos);
	float edgeWidth = min(sphereTextureWidth, sphereTextureHeight) * testValue;

	float edgeFactor = min(
		smoothEdge(1.0, edgeDistance.x, edgeWidth),
		smoothEdge(1.0, edgeDistance.y, edgeWidth)
		);
	return noise * edgeFactor;
}

float calculateDensityMap(int3 id, NoiseParams noise_params)
{
	float3 worldPos = (id / float(densityTextureSize-1.0) - 0.5) * planetSize;
	float halfS = planetSize / 2;
	float maxD = length(float3(halfS,halfS,halfS));
	float fudge = 1;
	float density = length(worldPos) / (maxD + fudge) - 0.5;
	// Noise
	//float noiseDensity = fbm(6, 2, 0.5, noiseScale, worldPos) * noiseHeightMultiplier;
	float noiseDensity = fbm(noise_params.numLayers, noise_params.lacunarity, noise_params.persistence, noise_params.noiseScale, worldPos) * noiseHeightMultiplier;
	density += noiseDensity;
	return density;
}

float calculateHeightMap(float2 pos, NoiseParams noise_params)
{
	float noiseContinentalness = fbm2dWithEdgeSmoothing(noise_params.numLayers, noise_params.lacunarity, noise_params.persistence,
		noise_params.noiseScale, pos) * noiseHeightMultiplier;

	/*
	float u = pos.y / float(sphereTextureWidth);
	float v = pos.x / float(sphereTextureHeight);
	float colorValue = u * v;
	// Dibujar un punto en el centro de la textura
	int2 centerCoords = int2(sphereTextureWidth / 2, sphereTextureHeight / 2);
	//noiseContinentalness = colorValue * noiseHeightMultiplier;  // Color distintivo, por ejemplo, blanco
	if (abs(pos.x - sphereTextureWidth) < testValue) {
		noiseContinentalness = 1.0 * noiseHeightMultiplier;  // Color distintivo, por ejemplo, blanco
	} else {
		noiseContinentalness = 0 * noiseHeightMultiplier;
	}
	*/
	return noiseContinentalness;
}

void SetHeightMap(int3 id, NoiseParams noise_params)
{
	float3 worldPos = (id / float(densityTextureSize) - 0.5) * planetSize;
	float2 equirectangularPos = SphericalToEquirectangular(worldPos);
	int2 textureCoords = int2(equirectangularPos.x * sphereTextureWidth, equirectangularPos.y * sphereTextureHeight);
	// Asegurarse de que las coordenadas estén dentro de los límites de la textura
	textureCoords.x = clamp(textureCoords.x, 0 , sphereTextureWidth);
	textureCoords.y = clamp(textureCoords.y, 0 , sphereTextureHeight);
	Generic2DNoiseTexture[textureCoords] = calculateHeightMap(textureCoords, noise_params);
}

void SetSphericalDensity(int3 cell) {
	NoiseParams noise_params = NoiseParamsBuffer[0];
	if (noise_params.noiseType == DENSITY_NOISE) {
		Generic3DNoiseTexture[cell] = calculateDensityMap(cell, noise_params);		
	} else if (noise_params.noiseType == HEIGHTMAP_NOISE) {
		SetHeightMap(cell, noise_params);
	}
}

float calculateDensity(int3 cell){
	float3 worldPos = (cell / float(densityTextureSize-1.0) - 0.5) * planetSize;
	float density = 0;
	// Noise
	float noise = fbm(6, 2, 0.5, noiseScale, worldPos) * noiseHeightMultiplier;
	//if (noise < 0)
	density += noise;
	return density;
}

[numthreads(8,8,8)]
void CSMain (int3 id : SV_DispatchThreadID)
{
	if (id.x >= densityTextureSize || id.y >= densityTextureSize || id.z >= densityTextureSize) {
		return;
	}
	SetSphericalDensity(id);
}
