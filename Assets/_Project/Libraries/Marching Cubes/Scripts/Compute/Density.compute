#pragma kernel CSMain
#include "Includes/Noise.compute"
#include "Includes/Utils.compute"

RWTexture3D<float> OutputMap;
RWTexture2DArray<float> NoiseTextures;
RWTexture2D<float> DebugHitsTexture;

RWTexture2D<float> ErosionTexture;
RWTexture2D<float> ContinentalnessTexture;
RWTexture2D<float> PeekAndValleysTexture;
RWTexture2D<float> TemperatureTexture;
RWTexture2D<float> HumidityTexture;
RWTexture3D<float> SquashFactorTexture;

StructuredBuffer<NoiseParams> NoiseParamsBuffer;
RWStructuredBuffer<uint> DensityMinMax;
int densityTextureSize;
int sphereTextureHeight;
int sphereTextureWidth;

float planetSize;
float3 planetCenter;
float isoLevel;
float noiseScale;
float noiseHeightMultiplier;
float testValue;

int2 calculateTextureCoords(int3 cell)
{
	float3 worldPos = (cell / float(densityTextureSize) - 0.5) * planetSize;
	float2 equirectangularPos = SphericalToEquirectangular(worldPos);
	int2 textureCoords = int2(equirectangularPos.x * sphereTextureWidth, equirectangularPos.y * sphereTextureHeight);
	textureCoords.x = clamp(textureCoords.x, 0 , sphereTextureWidth - 1);
	textureCoords.y = clamp(textureCoords.y, 0 , sphereTextureHeight - 1);
	return textureCoords;
}

float3 texCoordToWorld(int3 coord) {
	return (coord / float(densityTextureSize - 1) - 0.5f) * planetSize + planetCenter;
}

float fbm(int numLayers, float lacunarity, float persistence, float scale, float3 pos) {
	float noise = 0;
	float frequency = scale / 100;
	float amplitude = 1;

	for (int i = 0; i < numLayers; i ++) {
		float n = 1-abs(snoise(pos * frequency)*2-1);
		//n*=n;
		noise += n * amplitude;

		amplitude *= persistence;
		frequency *= lacunarity;
	}

	return noise;
}

float fbm2d(int numLayers, float lacunarity, float persistence, float scale, float2 pos) {	
	float noise = 0;
	float frequency = scale / 100;
	float amplitude = 1;

	for (int i = 0; i < numLayers; i ++) {
		float n = 1-abs(SNoise2D(pos * frequency)*2-1);
		//n*=n;
		noise += n * amplitude;

		amplitude *= persistence;
		frequency *= lacunarity;
	}
	return noise;
}

float periodicNoise2D(float2 pos)
{
	int heightLimit = sphereTextureHeight - 1;
	int widthLimit = sphereTextureWidth - 1;
	
    float2 p = float2(pos.x % widthLimit, pos.y % heightLimit); // Asegura que las coordenadas se repitan dentro del periodo
    float2 q = float2((pos.x - p.x) / widthLimit, (pos.y - p.y) / heightLimit); // Coordenadas locales normalizadas
	
    float a = SNoise2D(p);
	float lookupRange = 1;
    p = float2(pos.x + 1.0 * lookupRange % widthLimit, pos.y % heightLimit);
    float b = SNoise2D(p);
    p = float2(pos.x * lookupRange % widthLimit, pos.y + 1.0 * lookupRange % heightLimit);
    float c = SNoise2D(p);
    p = float2(pos.x + 1.0 * lookupRange % widthLimit, pos.y + 1.0 * lookupRange % heightLimit);
    float d = SNoise2D(p);

    float u = smoothstep(0.0, 1.0, q.x);
    float v = smoothstep(0.0, 1.0, q.y);

    return lerp(lerp(a, b, u), lerp(c, d, u), v);
}

float fbm2dPeriodic(int numLayers, float lacunarity, float persistence, float scale, float2 pos) {  
	float noise = 0;
	float frequency = scale / 100;
	float amplitude = 1;

	for (int i = 0; i < numLayers; i ++) {
		float n = 1 - abs(periodicNoise2D(pos * frequency) * 2 - 1);
		noise += n * amplitude;

		amplitude *= persistence;
		frequency *= lacunarity;
	}
	return noise;
}

float smoothEdge(float value, float edgeDistance, float edgeWidth)
{
	// edgeDistance: distancia del píxel al borde
	// edgeWidth: ancho del borde donde se aplicará el suavizado
	//return smoothstep(edgeWidth, 0.0, edgeDistance) * value;
	return smoothstep(0.0, edgeWidth, edgeDistance);
}

float fbm2dWithEdgeSmoothing(int numLayers, float lacunarity, float persistence, float scale, float2 pos)
{
	float noise = 0;
	float frequency = scale / 100;
	float amplitude = 1;

	for (int i = 0; i < numLayers; i++) {
		float n = periodicNoise2D(pos * frequency);
		noise += n * amplitude;

		amplitude *= persistence;
		frequency *= lacunarity;
	}

	// Calcular la distancia a los bordes
	float2 edgeDistance = min(pos, float2(sphereTextureWidth, sphereTextureHeight) - pos);
	float edgeWidth = min(sphereTextureWidth, sphereTextureHeight) * testValue;

	float edgeFactor = min(
		smoothEdge(1.0, edgeDistance.x, edgeWidth),
		smoothEdge(1.0, edgeDistance.y, edgeWidth)
		);
	return noise * edgeFactor;
}

float calculateDensityMap(int3 cell, NoiseParams noise_params)
{
	float3 worldPos = texCoordToWorld(cell);
	float halfS = planetSize / 2;
	float maxD = length(float3(halfS,halfS,halfS));
	float fudge = 1;
	float density = length(worldPos) / (maxD + fudge) - 0.5;
	// Noise
	//float noiseDensity = fbm(6, 2, 0.5, noiseScale, worldPos) * noiseHeightMultiplier;
	float noiseDensity = fbm(noise_params.numLayers, noise_params.lacunarity, noise_params.persistence, noise_params.noiseScale, worldPos) * noiseHeightMultiplier;
	density += noiseDensity;
	return density;
}

float calculateDensitySphere(int3 cell)
{
	float3 worldPos = texCoordToWorld(cell);
	float halfS = planetSize / 2;
	float maxD = length(float3(halfS,halfS,halfS));
	float fudge = 1;
	float density = length(worldPos) / (maxD + fudge);

	return density;
}

float heightMapNoise(float2 pos, NoiseParams noise_params)
{
	float noise = fbm2dWithEdgeSmoothing(noise_params.numLayers, noise_params.lacunarity, noise_params.persistence,
		noise_params.noiseScale, pos) * noiseHeightMultiplier;
	return noise;
}

void CalculateSphericalDensity(int3 cell) {
	NoiseParams noise_params = NoiseParamsBuffer[1];
	if (noise_params.noiseType == DENSITY_NOISE) {
		OutputMap[cell] = calculateDensityMap(cell, noise_params);
	} else if (noise_params.noiseType == HEIGHTMAP_NOISE) {
		//Revisar porque al tratar asi la densidad sumandola al mapa de alturas salen pequeños artefactos en la malla
		//Habría que ver si hay que suavizar o ajustar el cálculo de textureCoords
		//Calculo altura por ruido
		uint2 textureCoords = calculateTextureCoords(cell);
		float heightValue = heightMapNoise(textureCoords, noise_params);
		//Transformación de ruido 2D a 3D esférico
		float3 coord3d = texCoordToWorld(cell);
		float heightToPos = CalculateHeight(coord3d, planetCenter);
		float density = heightValue + heightToPos;
		float incremental = DebugHitsTexture[textureCoords];
		DebugHitsTexture[textureCoords] = incremental + 1.0f;
		NoiseTextures[uint3(textureCoords, 0)] = heightValue / noiseHeightMultiplier;
		OutputMap[cell] = density;
		if (density > 0) {
			uint ud = asuint(density);
			InterlockedMin(DensityMinMax[0], ud);
			InterlockedMax(DensityMinMax[1], ud);
		}
	}
}

float calculateDensity(int3 cell){
	float3 worldPos = (cell / float(densityTextureSize-1.0) - 0.5) * planetSize;
	float density = 0;
	// Noise
	float noise = fbm(6, 2, 0.5, noiseScale, worldPos) * noiseHeightMultiplier;
	//if (noise < 0)
	density += noise;
	return density;
}

[numthreads(8,8,8)]
void CSMain (int3 id : SV_DispatchThreadID)
{
	if (id.x >= densityTextureSize || id.y >= densityTextureSize || id.z >= densityTextureSize) {
		return;
	}
	CalculateSphericalDensity(id);
}
